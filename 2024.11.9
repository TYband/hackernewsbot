import os
import requests
import schedule
import time
from datetime import datetime
from deep_translator import GoogleTranslator
from github import Github
import logging

# 配置日志
logging.basicConfig(level=logging.INFO,  # 设置日志级别为 INFO
                    format='%(asctime)s - %(levelname)s - %(message)s',  # 设置输出格式
                    handlers=[logging.StreamHandler(), logging.FileHandler("hacknews_bot.log")])  # 同时输出到控制台和文件

# 配置
HACKERNEWS_API = "https://hacker-news.firebaseio.com/v0/topstories.json?print=pretty"
GITHUB_REPO = ""  # 替换为你的 GitHub 仓库
GITHUB_TOKEN = "your_github_token_here"  # 替换为你的 GitHub Token
GITHUB_DIR_PATH = ""  # 存放 Markdown 文件的目录

# 获取 Hacker News 数据
def get_hacker_news():
    logging.info("正在获取 Hacker News 数据...")
    response = requests.get(HACKERNEWS_API)
    top_ids = response.json()  # 获取所有新闻的 ID 列表
    news_items = []
    for item_id in top_ids:
        item_url = f"https://hacker-news.firebaseio.com/v0/item/{item_id}.json?print=pretty"
        item_response = requests.get(item_url)
        item = item_response.json()
        if item:
            news_items.append({
                "title": item.get("title"),
                "url": item.get("url", ""),  # 获取原始新闻链接
                "translation": None  # 初始为空
            })
    logging.info(f"成功获取到 {len(news_items)} 条 Hacker News 数据")
    return news_items

# 翻译新闻标题
def translate_news(news_items):
    logging.info("正在翻译新闻标题...")
    for item in news_items:
        # 修改目标语言为 zh-CN
        item['translation'] = GoogleTranslator(source='en', target='zh-CN').translate(item['title'])
    logging.info("新闻标题翻译完成")
    return news_items

# 生成 Markdown 内容
def generate_markdown(news_items, current_date):
    logging.info("正在生成 Markdown 文件内容...")
    template = '''---
layout: post
title: Hacknews {date} 新闻
category: Hacknews
tags: hacknews
keywords: hacknews
coverage: hacknews-banner.jpg
---


Hacker News 是一家关于计算机黑客和创业公司的社会化新闻网站，由保罗·格雷厄姆的创业孵化器 Y Combinator 创建。  
与其它社会化新闻网站不同的是 Hacker News 没有踩或反对一条提交新闻的选项（不过评论还是可以被有足够 Karma 的用户投反对票）；只可以赞或是完全不投票。简而言之，Hacker News 允许提交任何可以被理解为“任何满足人们求知欲”的新闻。

## HackNews Hack新闻

{items}
'''

    # 处理新闻项
    items = ""
    for item in news_items:
        # 使用新闻的原始链接
        items += f"- [{item['title']}]({item['url']})\n"
        items += f"- {item['translation']}\n"

    # 格式化模板，将 {date} 替换为实际的日期，{items} 替换为新闻列表
    markdown_content = template.format(date=current_date, items=items)
    logging.info("Markdown 文件内容生成完成")
    return markdown_content

# 上传到 GitHub 仓库
def upload_to_github(content, current_date):
    logging.info("正在上传到 GitHub...")
    g = Github(GITHUB_TOKEN)
    repo = g.get_repo(GITHUB_REPO)

    # 生成文件名格式：YYYY-MM-DD-hacknews.md
    filename = current_date + "-hacknews.md"
    file_path = os.path.join(GITHUB_DIR_PATH, filename)

    try:
        # 尝试获取文件内容
        file = repo.get_contents(file_path)
        # 文件存在，先获取当前内容
        current_content = file.decoded_content.decode("utf-8")

        # 检查新内容是否与当前内容相同
        if current_content == content:
            logging.info(f"内容与当前内容相同，跳过上传：{file_path}")
            return  # 如果内容相同，则跳过上传

        # 文件内容不同，更新文件
        repo.update_file(file.path, "Update Hacknews post", content, file.sha)
        logging.info(f"成功更新 {file_path} 在 GitHub 上")
    except Exception as e:
        # 如果文件不存在，则创建新的文件
        repo.create_file(file_path, "Create Hacknews post", content)
        logging.info(f"成功创建 {file_path} 在 GitHub 上")

# 获取当前日期并格式化
def get_current_date():
    return datetime.now().strftime('%Y-%m-%d')

# 定时任务函数
def scheduled_task():
    current_date = get_current_date()
    logging.info(f"任务开始，当前日期是: {current_date}")

    news_items = get_hacker_news()  # 获取所有 Hacker News 新闻
    news_items = translate_news(news_items)  # 翻译新闻
    markdown_content = generate_markdown(news_items, current_date)  # 生成 Markdown 内容
    upload_to_github(markdown_content, current_date)  # 上传到 GitHub

    logging.info(f"任务完成，{current_date} 的新闻已经上传到 GitHub")

# 主函数
def main():
    # 每3小时执行一次定时任务
    schedule.every(3).hours.do(scheduled_task)

    # 启动定时任务
    logging.info("脚本已启动，正在等待执行定时任务...")
    while True:
        schedule.run_pending()
        time.sleep(1)  # 稍等1秒钟，防止CPU占用过高

if __name__ == "__main__":
    main()
